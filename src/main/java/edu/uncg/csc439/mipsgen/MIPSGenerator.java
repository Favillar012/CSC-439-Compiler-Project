package edu.uncg.csc439.mipsgen;

import edu.uncg.csc439.icode.*;
import edu.uncg.csc439.icode.ICCreation.ICAddress;
import edu.uncg.csc439.icode.ICCreation.ICNames;
import edu.uncg.csc439.mipsgen.FlowGraph.BasicBlock;
import edu.uncg.csc439.mipsgen.FlowGraph.FCGraph;
import edu.uncg.csc439.mipsgen.MIPSCode.MIPSLine;
import edu.uncg.csc439.mipsgen.MIPSCode.MIPSLines;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * This class generates MIPS Assembly Code using a provided ICode object representing the
 * intermediate code.
 * @author Fernando Villarreal
 * @date 11/28/2020
 */
public class MIPSGenerator {

    //=================== CLASS VARIABLES ===================

    // Properties of the entire code:
    private MIPSLines programLines;             // All of the MIPSCode generated so far
    private ICode iCode;                        // ICode object representing the intermediate code
    private FCGraph fcGraph;                    // FCGraph created from the provided ICode object
    private ICDirective firstDefineDirective;   // First define byte or define word directive

    // Properties for the current function:
    private MIPSFunction mipsFunction;      // The current function
    private int paramsUsed;                 // Parameters used in the function
    private int localVarSize;               // Size of memory required for local variables
    private ProgState progState;            // ProgState object for the current function
    private int aRegistersUsed;             // Number of $a registers used in the current function
    private int stackFrameSize;             // Size of stack frame

    // Properties of the current basic block:
    private BasicBlock curBlock;                            // Current block
    private MIPSLines curBlockGenCode;                      // MIPSCode generated for the current block
    private HashMap<ICAddress, MIPSReg> valuesToSave;       // Set of values that need to be saved to memory

    //=================== CONSTRUCTOR ===================

    /**
     * Creates a new MIPSGenerator object which automatically generates MIPS Assembly Code
     * for the provided ICode object upon creation. Use the method 'getMipsLines()' to get the
     * generated code as a MIPSLines object.
     * @param iCode
     */
    public MIPSGenerator(ICode iCode) {
        this.iCode = iCode;
        this.programLines = new MIPSLines();
        this.fcGraph = new FCGraph(iCode);
        this.generateCode();
    }

    //=================== PUBLIC METHODS ===================

    /**
     * Get the MIPS Assembly Code generated by this MIPSGenerator object.
     * @return A MIPSLines object representing the generated code
     */
    public MIPSLines getProgramLines() {
        return this.programLines;
    }

    //=================== MIPS CODE CREATION ===================

    /**
     * Generate the MIPS Assembly Code using this class' fcGraph.
     */
    private void generateCode() {
        // Set the first define directive in the program
        this.setFirstDefineDirective(this.iCode.getIcLines());
        // Iterate over the list of basic blocks and produce the MIPS Code
        ArrayList<BasicBlock> blocksList = this.fcGraph.getBasicBlocksList();
        for (BasicBlock block : blocksList) {
            // Generate code for the block
            MIPSLines mipsLines = this.genCodeForBlock(block);
            this.programLines.addMIPSLines(mipsLines.getMIPSLineList());
        }
    }

    /**
     * Generate MIPS Assembly Code for a single basic block.
     * @param block
     * @return
     */
    private MIPSLines genCodeForBlock(BasicBlock block) {
        MIPSLines mipsLines = new MIPSLines();
        this.valuesToSave = new HashMap<>();
        ArrayList<ICLine> icLinesList = block.getIcLines().getICLinesList();
        // Generate code for each icLine
        for (ICLine icLine : icLinesList) {
            MIPSLines subLines = this.genCodeForLine(icLine);
            // Add the returned subLines to mipsLines
            mipsLines.addMIPSLines(subLines.getMIPSLineList());
        }
        // Save values in registers that need to be saved
        MIPSLines saveValuesLines = this.saveValues();
        mipsLines.addMIPSLines(saveValuesLines.getMIPSLineList());
        // Return lines
        return mipsLines;
    }

    /**
     * Generate MIPS Assembly Code for a single line of intermediate code.
     * @param icLine
     * @return
     */
    private MIPSLines genCodeForLine(ICLine icLine) {
        MIPSLines mipsLines = new MIPSLines();
        // The icLine is a line label
        if (this.isLineLabel(icLine)) {
            MIPSLine lineLabel = this.genLineLabel(icLine);
            mipsLines.addMIPSLine(lineLabel);
        }
        // The icLine is an unconditional goto statement
        if (icLine instanceof ICJump) {
            ICJump icJump = (ICJump)icLine;
            MIPSLine uncondBranch = this.genUnconditionalBranch(icJump);
            mipsLines.addMIPSLine(uncondBranch);
        }
        // The icLine is function start directive (Generate the function prologue)
        if (this.enteredFunction(icLine)) {
            ICDirective funcStartLine = (ICDirective)icLine;
            this.setParamsUsed(this.iCode.getIcLines(), funcStartLine);
            MIPSLines functionPrologue = this.genFunctionPrologue(this.iCode.getIcLines(), funcStartLine);
            mipsLines.addMIPSLines(functionPrologue.getMIPSLineList());
            // Set the current proState
            this.progState = new ProgState(this.mipsFunction, this.paramsUsed, this.localVarSize);
        }
        // The icLine is a math binary operation
        if (this.isMathBinOperation(icLine)) {
            ICBinOprt icBinOprt = (ICBinOprt)icLine;
            MIPSLines mipsBinOprt = this.genMathBinaryOperation(icBinOprt);
            mipsLines.addMIPSLines(mipsBinOprt.getMIPSLineList());
        }
        // The icLine is a relational jump instruction
        if (icLine instanceof ICReltJump) {
            ICReltJump icReltJump = (ICReltJump)icLine;
            MIPSLines condBranch = this.genConditionalBranch(icReltJump);
            mipsLines.addMIPSLines(condBranch.getMIPSLineList());
        }
        // The icLIne is a return statement
        if (icLine instanceof ICReturn) {
            ICReturn icReturn = (ICReturn)icLine;
            MIPSLines mipsReturn = this.genReturnLines(icReturn);
            mipsLines.addMIPSLines(mipsReturn.getMIPSLineList());
        }
        // The icLine is a function end directive (Generate the function epilogue)
        if (this.isFunctionEnd(icLine)) {
            MIPSLines functionEpilogue = this.genFunctionEpilogue(this.iCode.getIcLines());
            mipsLines.addMIPSLines(functionEpilogue.getMIPSLineList());
        }
        // The icLine is a define byte or define word directive
        if (this.isDefineByteWordDirective(icLine)) {
            // If this is the first define directive, put the '.data' tag in the program
            if (this.firstDefineDirective == icLine) {
                MIPSLine dataTag = new MIPSLine(".data", "");
                mipsLines.addMIPSLine(dataTag);
            }
            // Generate MIPS code for the directive
            ICDirective icDirective = (ICDirective)icLine;
            MIPSLine mipsLine = this.genDefineDirective(icDirective);
            // Add the mipsLine to lines and return it
            mipsLines.addMIPSLine(mipsLine);
        }
        // Return lines
        return mipsLines;
    }

    //=================== MIPSLINES CREATION FROM SPECIFIC ICLINE TYPES ===================

    /**
     * Generate a standalone line label in MIPS. A line label is a line of code with only a
     * label.
     * @param icLine
     * @return
     */
    private MIPSLine genLineLabel(ICLine icLine) {
        String label = icLine.getLabel();
        return new MIPSLine(label);
    }

    /**
     * Generate the unconditional branch statement in MIPS.
     * @param icJump
     * @return
     */
    private MIPSLine genUnconditionalBranch(ICJump icJump) {
        String gotoLabel = icJump.getGotoLabel();
        return new MIPSLine("b", gotoLabel);
    }

    /**
     * Generate a mathematical binary operation in MIPS.
     * @param icBinOprt
     * @return
     */
    private MIPSLines genMathBinaryOperation(ICBinOprt icBinOprt) {
        MIPSLines mipsLines = new MIPSLines();
        char charOprt = icBinOprt.getOperator().charAt(0);
        String operator = this.getMathOperator(charOprt);
        // Convert the operands to ICAddress objects
        String op1Str = icBinOprt.getAddress_2();
        String op2Str = icBinOprt.getAddress_3();
        ICAddress operand1 = this.convertTerm(op1Str, false);
        ICAddress operand2 = this.convertTerm(op2Str, false);
        // Get the registers for operand1 and operand2
        MIPSReg op1Reg = this.getRegister(operand1, null, null, mipsLines);
        MIPSReg op2Reg = this.getRegister(operand2, op1Reg, null, mipsLines);
        // MIPS Line: Perform the mathematical binary operation
        MIPSReg resultReg = this.progState.getAvailableRegister(op1Reg, op2Reg);
        MIPSLine binOprt = new MIPSLine(operator, resultReg.getName(), op1Reg.getName(), op2Reg.getName());
        mipsLines.addMIPSLine(binOprt);
        // Add the name and register for saving at the end of the curretn basic block
        ICAddress tempAdr = ICAddress.newTemp(4);
        this.progState.setNameIn(resultReg, tempAdr);
        this.valuesToSave.put(tempAdr, resultReg);
        // Return mipsLines
        return mipsLines;
    }

    /**
     * Generate a conditional branch operation for an IC relational jump.
     * @param icReltJump
     * @return
     */
    private MIPSLines genConditionalBranch(ICReltJump icReltJump) {
        MIPSLines mipsLines = new MIPSLines();
        String op1Str = icReltJump.getAddress_1();
        String op2Str = icReltJump.getAddress_2();
        String oprtStr = icReltJump.getRelOp();
        String gotoLabel = icReltJump.getGotoLabel();
        // Convert the elements
        ICAddress op1Name = this.convertTerm(op1Str, false);
        ICAddress op2Name = this.convertTerm(op2Str, false);
        String branchOprt = this.getBranchTypeFromRelOprt(oprtStr);
        // Get the registers for operators 1 and 2
        MIPSReg op1Reg = this.getRegister(op1Name, null, null, mipsLines);
        MIPSReg op2Reg = this.getRegister(op2Name, op1Reg, null, mipsLines);
        // Create the conditional branch operation
        MIPSLine condBranch = new MIPSLine(branchOprt, op1Reg.getName(), op2Reg.getName(), gotoLabel);
        mipsLines.addMIPSLine(condBranch);
        // Return mipsLines
        return mipsLines;
    }

    /**
     * Generate a single define byte or define word directive in MIPS.
     * @param icDirective
     * @return
     */
    private MIPSLine genDefineDirective(ICDirective icDirective) {
        MIPSLine mipsLine = new MIPSLine();
        ArrayList<String> mipsTerms = new ArrayList<>();
        int directiveType = icDirective.getDirectiveType();
        String defineType;
        String icDefineType;
        // The directive is define word directive
        if (directiveType == ICDirective.definedWord) {
            defineType = ".word";
            icDefineType = ".dw";
        }
        // The directive is a define byte directive
        else if (directiveType == ICDirective.definedByte) {
            defineType = ".byte";
            icDefineType = ".db";
        }
        // The directive is of an invalid type (Return null)
        else {
            return null;
        }
        // Get the terms from the icDirective
        ArrayList<String> directiveTerms = icDirective.getTerms();
        for (String term : directiveTerms) {
            if (term.compareTo(icDefineType) == 0) {
                term = defineType;
            }
            // Trim any trailing commas
            int termLength = term.length();
            if (termLength >= 2) {
                char lastChar = term.charAt(termLength - 1);
                if (lastChar == ',') {
                    term = term.substring(0, termLength - 1);
                }
            }
            // Add to mipsTerms
            mipsTerms.add(term);
        }
        // Set the terms and return mipsLine
        mipsLine.setTerms(mipsTerms);
        return mipsLine;
    }

    /**
     * Generate the function prologue in MIPS.
     * @param icLines
     * @param funcStartLine
     * @return
     */
    private MIPSLines genFunctionPrologue(ICLines icLines, ICDirective funcStartLine) {
        MIPSLines mipsLines = new MIPSLines();
        // Generate the first two lines of the prologue
        String funcLabel = funcStartLine.getLabel();
        MIPSLine firstLine = new MIPSLine(funcLabel);
        MIPSLine secondLine = new MIPSLine(".globl", funcLabel);
        mipsLines.addMIPSLine(firstLine);
        mipsLines.addMIPSLine(secondLine);
        // Set the current mipsFunction
        this.mipsFunction = new MIPSFunction(funcLabel.substring(3));
        // MIPS Lines: Allocate memory for the frame.
        String spRegName = MIPSReg.allReg().get(29).getName();
        int frameSize = this.determineStackFrameSize(icLines, funcStartLine);
        this.stackFrameSize = frameSize;
        String frameSizeStr = "" + frameSize;
        MIPSLine memoryAllocation = new MIPSLine("subu", spRegName, spRegName, frameSizeStr);
        mipsLines.addMIPSLine(memoryAllocation);
        // MIPS Lines: Save the values in the callee-saved registers.
        String raRegName = MIPSReg.allReg().get(31).getName();
        String fpRegName = MIPSReg.allReg().get(30).getName();
        String s7RegName = MIPSReg.allReg().get(23).getName();
        int relativeLocation = frameSize - 4;
        String raRegValLoc = relativeLocation + "(" + spRegName + ")";
        relativeLocation -= 4;
        String fpRegValLoc = relativeLocation + "(" + spRegName + ")";
        relativeLocation -= 4;
        String s7RegValLoc = relativeLocation + "(" + spRegName + ")";
        MIPSLine saveRaReg = new MIPSLine("sw", raRegName, raRegValLoc);
        MIPSLine saveFpReg = new MIPSLine("sw", fpRegName, fpRegValLoc);
        MIPSLine saveS7Reg = new MIPSLine("sw", s7RegName, s7RegValLoc);
        mipsLines.addMIPSLine(saveRaReg);
        mipsLines.addMIPSLine(saveFpReg);
        mipsLines.addMIPSLine(saveS7Reg);
        // MIPS Lines: Set the frame and s7 pointers.
        MIPSLine setFpPointer = new MIPSLine("addiu", fpRegName, spRegName, "" + relativeLocation);
        MIPSLine setS7Pointer = new MIPSLine("addiu", s7RegName, spRegName, frameSizeStr);
        mipsLines.addMIPSLine(setFpPointer);
        mipsLines.addMIPSLine(setS7Pointer);
        // Return mipsLines
        return mipsLines;
    }

    /**
     * Generate the return lines in MIPS. These lines move the value to return into the $v0
     * register and branch to the function epilogue.
     * @param icReturn
     * @return
     */
    private MIPSLines genReturnLines(ICReturn icReturn) {
        MIPSLines mipsLines = new MIPSLines();
        // MIPS Lines: Move return value to $v0 register
        String rValGenName = icReturn.getAddress();
        ICAddress rValAdr = this.convertTerm(rValGenName, false);
        MIPSReg rValReg = this.progState.getCurrReg(rValAdr);
        // Load the value onto the $v0 register if it's only in memory
        if (rValReg == null) {
            String canLoc = this.progState.getCanonicalLocation(rValAdr);
            MIPSReg returnReg = MIPSReg.allReg().get(2);
            MIPSLine loadToReg = new MIPSLine("lw", returnReg.getName(), canLoc);
            mipsLines.addMIPSLine(loadToReg);
        }
        // Move the value from its current register to the $vo register
        else {
            MIPSReg returnReg = MIPSReg.allReg().get(2);
            MIPSLine moveToReg = new MIPSLine("move", returnReg.getName(), rValReg.getName());
            mipsLines.addMIPSLine(moveToReg);
        }
        // MIPS Lines: Branch to function epilogue
        String epilogueLabel = "xf_" + this.mipsFunction.getName();
        MIPSLine branchLine = new MIPSLine("b", epilogueLabel);
        mipsLines.addMIPSLine(branchLine);
        // Return mipsLines
        return mipsLines;
    }

    /**
     * Generate the function epilogue in MIPS.
     * @param icLines
     * @return
     */
    private MIPSLines genFunctionEpilogue(ICLines icLines) {
        MIPSLines mipsLines = new MIPSLines();
        int frameSize = this.stackFrameSize;
        int relativeLocation = frameSize;
        // Set the label for the function epilogue
        String epilogueLabel = "xf_" + this.mipsFunction.getName();
        MIPSLine labelLine = new MIPSLine(epilogueLabel);
        mipsLines.addMIPSLine(labelLine);
        // MIPS Lines: Restore the values for the callee-saved registers
        String spRegName = MIPSReg.allReg().get(29).getName();
        String raRegName = MIPSReg.allReg().get(31).getName();
        String fpRegName = MIPSReg.allReg().get(30).getName();
        String s7RegName = MIPSReg.allReg().get(23).getName();
        relativeLocation -= 4;
        String raRegValLoc = "" + relativeLocation + "(" + spRegName + ")";
        relativeLocation -= 4;
        String fpRegValLoc = "" + relativeLocation + "(" + spRegName + ")";
        relativeLocation -= 4;
        String s7RegValLoc = "" + relativeLocation + "(" + spRegName + ")";
        MIPSLine loadS7Reg = new MIPSLine("lw", s7RegName, s7RegValLoc);
        MIPSLine loadFpReg = new MIPSLine("lw", fpRegName, fpRegValLoc);
        MIPSLine loadRaReg = new MIPSLine("lw", raRegName, raRegValLoc);
        mipsLines.addMIPSLine(loadS7Reg);
        mipsLines.addMIPSLine(loadFpReg);
        mipsLines.addMIPSLine(loadRaReg);
        // MIPS Line: Pop the stack frame
        MIPSLine popFrame = new MIPSLine("addiu", spRegName, spRegName, "" + frameSize);
        mipsLines.addMIPSLine(popFrame);
        // MIPS Line: Jump back to the calling procedure
        MIPSLine jumpBack = new MIPSLine("jr", raRegName);
        mipsLines.addMIPSLine(jumpBack);
        // Return mipsLines
        return mipsLines;
    }

    //=================== DETERMINE TYPE OF ICLINE METHODS ===================

    /**
     * Determine if a function has been entered.
     * @param icLine
     * @return
     */
    private boolean enteredFunction(ICLine icLine) {
        if (icLine instanceof ICDirective) {
            ICDirective icDirective = (ICDirective)icLine;
            int directiveType = icDirective.getDirectiveType();
            if (directiveType == ICDirective.fnStart) {
                return true;
            }
        }
        return false;
    }

    /**
     * Determine if icLine is a define byte or define word directive.
     * @param icLine
     * @return
     */
    private boolean isDefineByteWordDirective(ICLine icLine) {
        if (icLine instanceof ICDirective) {
            ICDirective icDirective = (ICDirective)icLine;
            int directiveType = icDirective.getDirectiveType();
            if (directiveType == ICDirective.definedWord) {
                return true;
            } else if (directiveType == ICDirective.definedByte) {
                return true;
            }
        }
        return false;
    }

    //=================== OTHER PRIVATE HELPER METHODS ===================

    /**
     * Scan through a function and count the largest number of argument registers ($a) that are used
     * to pass arguments to another function that is called.
     * @param icLines The ICLines in the IC program
     * @param funcStartLine The ICLine in icLines where the function starts
     * @return
     */
    private int countArgRegisterstoUse(ICLines icLines, ICDirective funcStartLine) {
        int largestCount = 0;
        int curCount = 0;
        // Scan through icLines to find the 'param1' or 'param4' term
        int startIndex = icLines.getICLinesList().indexOf(funcStartLine);
        int endIndex = this.getIndexOfFunctionEnd(icLines, funcStartLine);
        for (int index = startIndex; index < endIndex; index++) {
            ICLine curLine = icLines.getICLine(index);
            // Scan all of the terms in the curLine
            ArrayList<String> curLineTerms = curLine.getTerms();
            for (String term : curLineTerms) {
                if (term.compareTo("param1") == 0) {
                    curCount++;
                } else if (term.compareTo("param4") == 0) {
                    curCount++;
                // When the 'call' term is found, reset and update the largestCount
                } else if (term.compareTo("call") == 0) {
                    if (curCount > largestCount) {
                        largestCount = curCount;
                    }
                    curCount = 0;
                }
            }
        }
        // Return the largestCount
        return largestCount;
    }

    /**
     * Determine the size of the stack frame for the function that corresponds to the provided
     * ICLine funcStartLine.
     * @param icLines
     * @param funcStartLine
     * @return
     */
    private int determineStackFrameSize(ICLines icLines, ICDirective funcStartLine) {
        int frameSize = 12; // 12 bytes for the callee-saved registers
        int startIndex = icLines.getICLinesList().indexOf(funcStartLine);
        int endIndex = this.getIndexOfFunctionEnd(icLines, funcStartLine);
        // Get the size for the local variables
        this.localVarSize = this.getLocalVariablesSize(funcStartLine);
        frameSize += this.localVarSize;
        // Get the size for the temporaries variables
        int tempVarSize = 0;
        for (int index = startIndex; index < endIndex; index++) {
            ICLine curLine = icLines.getICLine(index);
            // Check every term to see if it's a temporary variable
            ArrayList<String> curLineTerms = curLine.getTerms();
            for (String term : curLineTerms) {
                if (!term.isEmpty()) {
                    char nameType = ICNames.getNameTypeOfGenName(term);
                    // The term is a temporary variable
                    if (nameType == ICNames.temporaryName) {
                        char objectType = ICNames.getObjectTypeOfGenName(term);
                        if (objectType == ICNames.integerType) {
                            tempVarSize += 4;
                        } else if (objectType == ICNames.characterType) {
                            tempVarSize += 1;
                        }
                    }
                }
            }
        }
        frameSize += tempVarSize;
        // Get the size for the values in argument registers that need to be saved to memory
        int registerToSave = this.aRegistersUsed;
        int argRegValuesSize = registerToSave * 4; // Just save all the values in 4 bytes each
        frameSize += argRegValuesSize;
        // Return frameSize
        return frameSize;
    }

    /**
     * Get the size (in bytes) required to store the local variables of the function in its stack frame.
     * @param funcStartLine The function start directive corresponding to the function
     * @return
     */
    private int getLocalVariablesSize(ICDirective funcStartLine) {
        int locVarSize;
        String locVarSizeString = funcStartLine.getFirstParameter();
        try {
            locVarSize = Integer.parseInt(locVarSizeString);
        } catch (NumberFormatException ex) {
            locVarSize = 0;
        }
        return locVarSize;
    }

    /**
     * Determine if the provided ICLine is a function end directive.
     * @param icLine
     * @return
     */
    private boolean isFunctionEnd(ICLine icLine) {
        if (icLine instanceof ICDirective) {
            ICDirective icDirective = (ICDirective)icLine;
            int directiveType = icDirective.getDirectiveType();
            if (directiveType == ICDirective.fnEnd) {
                return true;
            }
        }
        return false;
    }

    /**
     * Set the first define directive in the program.
     * @param icLines
     */
    private void setFirstDefineDirective(ICLines icLines) {
        // Scan through icLines and find the first define directive in the program
        for (ICLine icLine : icLines.getICLinesList()) {
            if (icLine instanceof ICDirective) {
                ICDirective icDirective = (ICDirective)icLine;
                int directiveType = icDirective.getDirectiveType();
                if (directiveType == ICDirective.definedByte || directiveType == ICDirective.definedWord) {
                    this.firstDefineDirective = icDirective;
                    return;
                }
            }
        }
    }

    /**
     * Set the number of parameters used for the current function.
     * @param icLines
     * @param funcStartLine
     */
    private void setParamsUsed(ICLines icLines, ICDirective funcStartLine) {
        int parCount = 0;
        int startIndex = icLines.getICLinesList().indexOf(funcStartLine);
        int length = icLines.getSize();
        for (int index = startIndex; index < length; index++) {
            ICLine curLine = icLines.getICLine(index);
            ArrayList<String> curLineTerms = curLine.getTerms();
            for (String term : curLineTerms) {
                if (!term.isEmpty() && term.length() >= 4) {
                    char firstChar = term.charAt(0);
                    char thirdChar = term.charAt(2);
                    if (firstChar == 'p' && thirdChar == '@') {
                        parCount++;
                    }
                }
            }
        }
        this.paramsUsed = parCount;
    }

    /**
     * Get the index for the end of the function given the line where it starts.
     * @param icLines
     * @param funcStartLine
     * @return
     */
    private int getIndexOfFunctionEnd(ICLines icLines, ICDirective funcStartLine) {
        int startIndex = icLines.getICLinesList().indexOf(funcStartLine);
        int length = icLines.getSize();
        for (int index = startIndex; index < length; index++) {
            ICLine curLine = icLines.getICLine(index);
            if (this.isFunctionEnd(curLine)) {
                return index;
            }
        }
        // Error
        return -1;
    }

    /**
     * Determine if the provided icLine is a mathematical binary operation.
     * @param icLine
     * @return
     */
    private boolean isMathBinOperation(ICLine icLine) {
        if (icLine instanceof ICBinOprt) {
            ICBinOprt icBinOprt = (ICBinOprt)icLine;
            char opChar = icBinOprt.getOperator().charAt(0);
            if (opChar == '+') {
                return true;
            } else if (opChar == '-') {
                return true;
            } else if (opChar == '*') {
                return true;
            } else if (opChar == '/') {
                return true;
            }
        }
        return false;
    }

    /**
     * Get the math operator in MIPS for the specified operator.
     * @param operator
     * @return
     */
    private String getMathOperator(char operator) {
        if (operator == '+') {
            return "addu";
        } else if (operator == '-') {
            return "subu";
        } else if (operator == '*') {
            return "mult";
        } else if (operator == '/') {
            return "divu";
        }
        return "???";
    }

    /**
     * Determine if the provided ICLine is a line label. A line label is an IC line that has
     * a generated label not associated with a program entity and all other terms of the line
     * are empty. Example: "L2:        " is a line label.
     * @param icLine
     * @return
     */
    private boolean isLineLabel(ICLine icLine) {
        String label = icLine.getLabel();
        // Check if the label is a generated line label
        if (label.length() == 2) {
            char labelChar = label.charAt(0);
            if (labelChar != 'L') {
                return false;
            }
            // Check if the rest of the terms are not empty
            ArrayList<String> terms = icLine.getTerms();
            int length = terms.size();
            for (int i = 1; i < length; i++) {
                String term = terms.get(i);
                if (!term.isEmpty()) {
                    return false;
                }
            }
            // The icLine is a line label
            return true;
        } else {
            return false;
        }
    }

    /**
     * Get the appropriate type of branch instruction based on the relation operator provided.
     * @param relOp
     * @return
     */
    private String getBranchTypeFromRelOprt(String relOp) {
        if (relOp.compareTo("<") == 0) {
            return "blt";
        } else if (relOp.compareTo("<=") == 0) {
            return "ble";
        } else if (relOp.compareTo(">") == 0) {
            return "bgt";
        } else if (relOp.compareTo(">=") == 0) {
            return "bge";
        } else if (relOp.compareTo("==") == 0) {
            return "beq";
        } else if (relOp.compareTo("!=") == 0) {
            return "bne";
        } else {
            return "???";
        }
    }

    /**
     * Check if the provided term is an integer literal.
     * @param term
     * @return
     */
    private boolean isIntLit(String term) {
        try {
            Integer.parseInt(term);
            return true;
        } catch (NumberFormatException ex) {
            return false;
        }
    }

    /**
     * Convert the provided term into an ICAddress representing the same term.
     * @param term
     * @param isLabel
     * @return
     */
    private ICAddress convertTerm(String term, boolean isLabel) {
        if (!this.isIntLit(term)) {
            return ICAddress.convertGeneratedName(term, isLabel);
        } else {
            int intLit = Integer.parseInt(term);
            return ICAddress.newLitInt(intLit);
        }
    }

    /**
     * Generate a MIPS instruction to load the provided ICAddress onto an available register.
     * @param icAddress
     * @return
     */
    private MIPSLine loadToRegister(ICAddress icAddress, MIPSReg avoid1, MIPSReg avoid2) {
        String canLoc = this.progState.getCanonicalLocation(icAddress);
        MIPSReg availReg = this.progState.getAvailableRegister(avoid1, avoid2);
        MIPSLine mipsLine = new MIPSLine("lw", availReg.getName(), canLoc);
        this.progState.loadValue(availReg, icAddress);
        return mipsLine;
    }

    /**
     * Get the register (or a register) for the specified ICAddress name. The ICAddress might need
     * to be loaded onto an available register.
     * @param name The ICAddress to get the register for.
     * @param avoid1 Register to avoid using if the value must be loaded onto an available register.
     * @param avoid2 Register to avoid using if the value must be loaded onto an available register.
     * @param mipsLines The MIPSLines object to add the load instructions to if necessary.
     * @return
     */
    private MIPSReg getRegister(ICAddress name, MIPSReg avoid1, MIPSReg avoid2, MIPSLines mipsLines) {
        MIPSReg register;
        // Get the register if it exists
        if (name.isParam()) {
            register = this.progState.getCanonicalReg(name);
        } else {
            register = this.progState.getCurrReg(name);
        }
        // If the register is null, load ICAddress name onto an available register.
        if (register == null) {
            MIPSLine loadOp1ToReg = this.loadToRegister(name, avoid1, avoid2);
            mipsLines.addMIPSLine(loadOp1ToReg);
            register = this.progState.getCurrReg(name);
        }
        // Return the register
        return register;
    }

    /**
     * Save any and all values in registers that need to be saved at the end of a basic block.
     * @return
     */
    private MIPSLines saveValues() {
        MIPSLines mipsLines = new MIPSLines();
        this.valuesToSave.forEach( (name, register) -> {
            // Save the value if it's not already saved
            if (!this.progState.isSaved(name)) {
                this.progState.storeValue(name, register);
                String srcRegName = register.getName();
                String dstAdrLoc = this.progState.getCanonicalLocation(name);
                MIPSLine mipsLine = new MIPSLine("sw", srcRegName, dstAdrLoc);
                mipsLines.addMIPSLine(mipsLine);
            }
        });
        // Return mipsLines
        return mipsLines;
    }
}
