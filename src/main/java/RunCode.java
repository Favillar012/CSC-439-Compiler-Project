import edu.uncg.csc439.LCErrorListener;
import edu.uncg.csc439.LCListener;
import edu.uncg.csc439.antlr4.LittleCLexer;
import edu.uncg.csc439.antlr4.LittleCParser;
import edu.uncg.csc439.icinterp.ICInterp;
import edu.uncg.csc439.icode.ICode;
import edu.uncg.csc439.syntaxtree.LCSyntaxTree;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import java.io.IOException;
import java.nio.file.NoSuchFileException;
import java.util.LinkedList;

/**
 * This program runs the input LittleC program through the provided lexical
 * analyzer and parser, producing a syntax tree, which is then send to ICode
 * to generate intermediate code. Finally, a text representation of this code
 * is generated by ICode.toString(), and this is sent to the intermediate
 * code interpreter to run. The end effect is that the LittleC program is
 * run....
 *
 * @author Steve Tate (srtate@uncg.edu)
 */

public class RunCode {
    /**
     * Runs the parser and edu.uncg.csc439.LCListener syntax tree constructor for the
     * provided input stream. The returned object can be used to access
     * the syntax tree and the symbol table for either futher processing or
     * for checking results in automated tests.
     *
     * @param input an initialized CharStream
     * @return the edu.uncg.csc439.LCListener object that processed the parsed
     *         input or null if an error was encountered
     */

    private static LCListener parseStream(CharStream input) {
        // "input" is the character-by-character input - connect to lexer
        LittleCLexer lexer = new LittleCLexer(input);
        LCErrorListener catchErrs = new LCErrorListener();
        lexer.addErrorListener(catchErrs);

        // Connect token stream to lexer
        CommonTokenStream tokens = new CommonTokenStream(lexer);

        // Connect parser to token stream
        LittleCParser parser = new LittleCParser(tokens);
        parser.addErrorListener(catchErrs);
        ParseTree tree = parser.program();
        if (catchErrs.sawError())
            return null;

        // Now do the parsing, and walk the parse tree with our listeners
        ParseTreeWalker walker = new ParseTreeWalker();
        LCListener compiler = new LCListener(parser);
        walker.walk(compiler, tree);

        return compiler;
    }

    /**
     * Public static method to run the parser on an input file.
     *
     * @param fileName the name of the file to use for input
     * @return the edu.uncg.csc439.LCListener object that processed the parsed input
     */
    public static LCListener parseFromFile(String fileName) {
        try {
            return parseStream(CharStreams.fromFileName(fileName));
        } catch (IOException e) {
            if (e instanceof NoSuchFileException) {
                System.err.println("Could not open file " + fileName);
            } else {
                e.printStackTrace();
            }
        }
        return null;
    }

    /**
     * Public static method to run the parser on the standard input stream.
     *
     * @return the edu.uncg.csc439.LCListener object that processed the parsed input
     */
    public static LCListener parseFromStdin() {
        try {
            return parseStream(CharStreams.fromStream(System.in));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Command line interface -- one argument is filename, and if omitted then
     * input is taken from standard input.
     *
     * @param argv command line arguments
     */
    public static void main(String[] argv) {
        LCListener parser;
        if (argv.length > 1) {
            System.err.println("Can provide at most one command line argument (an input filename)");
            return;
        } else if (argv.length == 1) {
            parser = parseFromFile(argv[0]);
        } else {
            parser = parseFromStdin();
        }

        LCSyntaxTree result = null;
        if (parser != null)
            result = parser.getSyntaxTree();

        if (result != null) {
            ICode iCode = new ICode(result);
            String codeAsStr = iCode.toString();
            ICInterp context = new ICInterp(codeAsStr);
            context.executeFunction("gf_main", new LinkedList<>());
        }
    }
}
